//============================================================================
// Name        : multiplecam.cpp
// Author      : Sara Turriziani
// Version     : 4.0
// Copyright   : Mini-EUSO copyright notice
// Description : Cameras Acquisition Module in C++, ANSI-style, for linux
//============================================================================


#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <sstream>
#include <fstream>
#include <math.h>
#include <time.h>
#include <ctime>
#include <sys/time.h>
#include <unistd.h>
#include <signal.h>
#include "/usr/include/flycapture/FlyCapture2.h"
using namespace FlyCapture2;
using namespace std;

volatile sig_atomic_t done = 0;

// using global pointer/handler for test
Camera *pCameras;
FlyCapture2::CallbackHandle m_resetHandle;
FlyCapture2::CallbackHandle m_arrivalHandle;
FlyCapture2::CallbackHandle m_removalHandle;

void term(int signum)
{
    done = 1;
}

unsigned createMask(unsigned a, unsigned b)
{
	unsigned int r = 0;
	for (unsigned i = a; i < b; i++)
	{
		r = r+1;
		r  = r*2;
	}
	r = r + 1;
	return r;
}

// test time in ms
const std::string currentDateTime2() {
 timeval curTime;
 gettimeofday(&curTime, NULL);
 int milli = curTime.tv_usec / 1000;
 struct tm timeinfo;
 char buffer [80];
 strftime(buffer, sizeof(buffer), "%Y-%m-%d.%H-%M-%S", localtime_r(&curTime.tv_sec, &timeinfo));
 char currentTime[84] = "";
 sprintf(currentTime, "%s.%03d", buffer, milli);

 return currentTime;

  }

inline void delay( unsigned long ms )
    {
    usleep( ms * 1000 );
    }



void PrintBuildInfo()
{
    FC2Version fc2Version;
    Utilities::GetLibraryVersion( &fc2Version );
    char version[128];
    sprintf(
        version,
        "FlyCapture2 library version: %d.%d.%d.%d\n",
        fc2Version.major, fc2Version.minor, fc2Version.type, fc2Version.build );

    printf( version );

    char timeStamp[512];
    sprintf( timeStamp, "Application build date: %s %s\n\n", __DATE__, __TIME__ );

    printf( timeStamp );
}

void PrintCameraInfo( CameraInfo* pCamInfo )
{
    printf(
        "\n*** CAMERA INFORMATION ***\n"
        "Serial number - %u\n"
        "Camera model - %s\n"
        "Camera vendor - %s\n"
        "Sensor - %s\n"
        "Resolution - %s\n"
        "Firmware version - %s\n"
        "Firmware build time - %s\n\n",
        pCamInfo->serialNumber,
        pCamInfo->modelName,
        pCamInfo->vendorName,
        pCamInfo->sensorInfo,
        pCamInfo->sensorResolution,
        pCamInfo->firmwareVersion,
        pCamInfo->firmwareBuildTime );
}

void PrintError( Error error )
{
    error.PrintErrorTrace();
}

enum ExtendedShutterType
{
    NO_EXTENDED_SHUTTER,
    GENERAL_EXTENDED_SHUTTER
};


std::string GetCurrentTimeString() {
	time_t rawtime;
	struct tm * timeinfo;
	time( &rawtime );
	timeinfo = localtime( &rawtime );

	std::ostringstream formatTime;
	formatTime << (timeinfo->tm_year + 1900) << "-"
		<< (timeinfo->tm_mon + 1) << "-"
		<< (timeinfo->tm_mday) << " "
		<< (timeinfo->tm_hour) << ":"
		<< (timeinfo->tm_min) << ":"
		<< (timeinfo->tm_sec);

	return formatTime.str();
}


void OnBusReset( void* pParam, unsigned int serialNumber )
{
	std::cout << GetCurrentTimeString() << " - *** BUS RESET ***" << std::endl;
	
//	delete[] pCameras;
//	exit(EXIT_SUCCESS);
	exit(EXIT_FAILURE);

}

void OnBusArrival( void* pParam, unsigned int serialNumber )
{
	std::cout << GetCurrentTimeString() << " - *** BUS ARRIVAL (" << serialNumber << ") ***" << std::endl;

//	delete[] pCameras;
//	exit(EXIT_SUCCESS);
	exit(EXIT_FAILURE);

}

void OnBusRemoval( void* pParam, unsigned int serialNumber )
{
	std::cout << GetCurrentTimeString() << " - *** BUS REMOVAL (" << serialNumber << ") ***" << std::endl;

//	delete[] pCameras;
//	exit(EXIT_SUCCESS);
	exit(EXIT_FAILURE);

}
 

int BusResetLoop()
{
	BusManager busMgr;

//	FlyCapture2::CallbackHandle m_resetHandle;
//	FlyCapture2::CallbackHandle m_arrivalHandle;
//	FlyCapture2::CallbackHandle m_removalHandle;

	// Register bus events
	Error error;
	error = busMgr.RegisterCallback(&OnBusReset,BUS_RESET,NULL,&m_resetHandle );
	if ( error != PGRERROR_OK )
	{
		PrintError( error );
		return -1;
	}

	error = busMgr.RegisterCallback(&OnBusArrival,ARRIVAL,NULL,&m_arrivalHandle );
	if ( error != PGRERROR_OK )
	{
		PrintError( error );
		return -1;
	}

	error = busMgr.RegisterCallback(&OnBusRemoval, REMOVAL,NULL,&m_removalHandle );
	if ( error != PGRERROR_OK )
	{
		PrintError( error );
		return -1;
	}



        // 

/*
	// Unregister bus events
	error = busMgr.UnregisterCallback( m_resetHandle );
	if ( error != PGRERROR_OK )
	{
		PrintError( error );
		return -1;
	}

	error = busMgr.UnregisterCallback( m_arrivalHandle );
	if ( error != PGRERROR_OK )
	{
		PrintError( error );
		return -1;
	}

	error = busMgr.UnregisterCallback( m_removalHandle );
	if ( error != PGRERROR_OK )
	{
		PrintError( error );
		return -1;
	}
*/

	return 0;
}

//int main(int /*argc*/, char** /*argv*/)
int main(int argc, char* argv[])
{

    struct sigaction action;
    memset(&action, 0, sizeof(struct sigaction));
    action.sa_handler = term;
    if (sigaction(SIGTERM, &action, NULL) == -1) {
        perror("Error: cannot handle SIGTERM"); // Should not happen
    }   

    if (sigaction(SIGINT, &action, NULL) == -1) {
        perror("Error: cannot handle SIGINT"); // Should not happen
    }

        if (sigaction(SIGHUP, &action, NULL) == -1) {
        perror("Error: cannot handle SIGHUP"); // Should not happen
    }


	unsigned int ulValue;
	CameraInfo camInfo;

		
    PrintBuildInfo();
    Error error;
    // Since this application saves images in the current folder
    // we must ensure that we have permission to write to this folder.
    // If we do not have permission, fail right away.
	FILE* tempFile = fopen("test.txt", "w+");
	if (tempFile == NULL)
	{
		printf("Failed to create file in current folder.  Please check permissions.\n");
		return -1;
	}
	fclose(tempFile);
	remove("test.txt");

    BusManager busMgr;
    unsigned int numCameras;

    int retValue = BusResetLoop();
	if ( retValue != 0 )
	{
        PrintError( error );	
	return -1;
	}
   

    error = busMgr.GetNumOfCameras(&numCameras);
    if (error != PGRERROR_OK)
    {
        PrintError( error );
        return -1;
    }

   
    printf( "Number of cameras detected: %u\n", numCameras );

//    Camera *pCameras = new Camera[numCameras]; // initialize an array of cameras
	pCameras = new Camera[numCameras]; // initialize an array of cameras

    for (unsigned int i=0; i < numCameras; i++)
          {
            PGRGuid guid;
            error = busMgr.GetCameraFromIndex(i, &guid);
            if (error != PGRERROR_OK)
             {
                PrintError( error );
                delete[] pCameras;
                return -1;
             }

            error = pCameras[i].Connect(&guid); // connect both cameras
            if (error != PGRERROR_OK)
              {
                PrintError(error);
                delete[] pCameras;
                return -1;
               }

          error = pCameras[i].GetCameraInfo(&camInfo);
          if (error != PGRERROR_OK)
           {
             PrintError(error);
             delete[] pCameras;
             return -1;
            }

          PrintCameraInfo(&camInfo);


    // Get the camera configuration
    FC2Config config;
    error = pCameras[i].GetConfiguration(&config);
    if (error != PGRERROR_OK)
    {
        PrintError(error);
        return -1;
    }

                        cout << "Setting FRAME_RATE to OFF"  << endl;
                        // Turn off frame rate
                         Property prop;
                         prop.type = FRAME_RATE;
                         error =  pCameras[i].GetProperty( &prop );
                         if (error != PGRERROR_OK)
                           {
                             PrintError( error );
                             delete[] pCameras;
                             return -1;
                            }

                         prop.autoManualMode = false;
                         prop.onOff = false;
                         error =  pCameras[i].SetProperty( &prop );
                         if (error != PGRERROR_OK)
                           {
                             PrintError( error );
                             delete[] pCameras;
                             return -1;
                           }
                         

        // Set the shutter property of the camera

            PropertyInfo Shut;
            Shut.type = SHUTTER;
            error = pCameras[i].GetPropertyInfo( &Shut );
            if (error != PGRERROR_OK)
              {
                PrintError( error );
                delete[] pCameras;
                return -1;
              }

             Property shutter;
             shutter.type = SHUTTER;
             shutter.absControl = true;
             shutter.onePush = false;
             shutter.autoManualMode = false;
             shutter.onOff = true;

             float shutt = 100;
             
             shutter.absValue = shutt;

             error = pCameras[i].SetProperty( &shutter );
             if (error != PGRERROR_OK)
               {
                PrintError( error );
                delete[] pCameras;
                return -1;
               }

	// Set the grab timeout to 100ms
//	config.grabTimeout = 3*shutt;
        config.grabTimeout = 15*shutt;

	// Set the camera configuration
	error = pCameras[i].SetConfiguration(&config);
	if (error != PGRERROR_OK)
	{
		PrintError(error);
		return -1;
	}


       


     // Start streaming on camera
            std::stringstream ss;
            ss << currentDateTime2();
            std::string st = ss.str();
            char pippo[st.length()];
            sprintf(pippo, "%s" , st.c_str() );
            printf( "Start time %s \n", pippo );


            error = pCameras[i].StartCapture();
            if (error != PGRERROR_OK)
              {
                PrintError(error);
                delete[] pCameras;
                return -1;
              }
          }
           
    int imageCnt=0; // uncomment this and other lines beginning with /// & comment previous line to get an indefinite loop
    
 while (!done)
     {

          
    	 for (unsigned int i = 0; i < numCameras; i++)
    	    {

				int retValue = BusResetLoop();
				if ( retValue != 0 )
				{
					PrintError(error);
					delete[] pCameras;
					return -1;
				}

    	      Image image;
    	      error = pCameras[i].RetrieveBuffer(&image);

				retValue = BusResetLoop();
				if ( retValue != 0 )
				{
					PrintError(error);
					delete[] pCameras;
					return -1;
				}


    	      if (error != PGRERROR_OK)
    	        {
    	          PrintError(error);
    	          delete[] pCameras;
    	          return -1;
    	        }


    	         // Save the file

    	      unsigned int res =	 0; // for initialization purposes

    	      Property shutter;
    	      shutter.type = SHUTTER;
    	      error = pCameras[i].GetProperty( &shutter );
    	      if (error != PGRERROR_OK)
    	        {
    	          PrintError( error );
    	          return -1;
    	        }


    	      error = pCameras[i].GetCameraInfo(&camInfo);
    	      if (error != PGRERROR_OK)
    	        {
    	          PrintError(error);
    	          delete[] pCameras;
    	          return -1;
    	        }

    	      
    	        PixelFormat pixFormat;
    	        unsigned int rows, cols, stride;
    	        image.GetDimensions( &rows, &cols, &stride, &pixFormat );

    	       // Create a unique filename

    	       std::string str;     //temporary string to hold the filename
    	       int lengthOfString1; //hold the number of characters in the string
    	       std::stringstream sstm;
    	       std::string head;
    	       

    	       sstm  << currentDateTime2();
    	       str = sstm.str();
    	       lengthOfString1=str.length();

    	       int lenghtsum = lengthOfString1 + 4  + 4 + 3;
    	       char filename[lenghtsum];
    	       sprintf(filename,"%s.raw", str.c_str() );
    	       //     cout << filename << endl; // uncomment for testing purposes

    	       unsigned int iImageSize = image.GetDataSize();
    	       printf( "Grabbed image %s \n", filename );
//    	                 printf( "Frame rate is %3.1f fps\n", frmRate.absValue );
    	       printf( "Shutter is %3.1f ms\n", shutter.absValue );
    	      
    	       cout << "Raw Image Dimensions: " << rows  << " x " << cols << " Image Stride: " << stride << endl;
    	       cout << "Image Size: " << iImageSize << endl;

    	      // Save the image. If a file format is not passed in, then the file
    	     // extension is parsed to attempt to determine the file format.
    	       error = image.Save( filename );
    	       if (error != PGRERROR_OK)
    	         {
    	           PrintError( error );
    	           delete[] pCameras;
    	           return -1;
    	         }


      }

   	 imageCnt++;
     }

    std::stringstream ss1;
    ss1 << currentDateTime2();
    std::string st1= ss1.str();
    char pippo1[st1.length()];
    sprintf(pippo1 , "%s" , st1.c_str() );
    printf("Kill signal received. Exiting. \n");
    printf( "End time time %s \n", pippo1 );



    // disconnect the camera

    for (unsigned int  i= 0; i < numCameras; i++)
        {
          pCameras[i].StopCapture();
          pCameras[i].Disconnect();
        }

        delete[] pCameras;

    return 0;
}

